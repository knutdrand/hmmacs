import numpy as np
from scipy.special import logsumexp
from hmmlearn.base import _BaseHMM
from hmmlearn._utils import check_is_fitted
from hmmlearn.utils import iter_from_X_lengths, log_mask_zero
from sklearn.utils import check_array
"""
transmat: t_{ij} from i to j
"""
def diagonalize(matrices):
    l, p = np.linalg.eig(matrices)
    return p, l, np.linalg.inv(p)

class _BaseSparseHMM(_BaseHMM):
    def score(X, lengths=None):
        pass

    def score(self, X, run_lengths, lengths=None):
        check_is_fitted(self, "startprob_")
        self._check()

        X = check_array(X)
        # XXX we can unroll forward pass for speed and memory efficiency.
        logprob = 0
        for i, j in iter_from_X_lengths(X, lengths):
            framelogprob = self._compute_log_likelihood(X[i:j])
            logprobij, _fwdlattice = self._do_forward_pass(framelogprob, run_lengths[i:j])
            logprob += logprobij
        return logprob

    def __get_lpdps(self, framelogprob):
        matrices = self.transmat_[None, ...] * np.exp(framelogprob[:, None, : ]) #add f_i to row i of t
        tmp = (self.startprob_ * np.exp(framelogprob[0]))[None, :]
        ms = diagonalize(matrices)
        lps, ilds, lp_invs = (np.log(np.abs(m)) for m in ms)
        sps, sds, sp_invs = (np.sign(m) for m in ms)
        return (lps, ilds, lp_invs), (sps, sds, sp_invs)

    def _do_backward_pass(self, framelogprob, lengths):
        n_samples, n_components = framelogprob.shape
        (lps, ilds, lp_invs), (sps, sds, sp_invs) = self.__get_lpdps(framelogprob)
        lds = ilds*lengths
        bwdlattice = np.zeros((n_samples, n_components))
        lv = bwdlattice[-1]
        for t in range(n_samples-1, 0, -1):
            lp, ld, lr = (lps[t], lds[t], lp_invs[t])
            sp, sd, sr = (sps[t], sds[t], sp_invs[t])
            for i in range(2):
                bwdlattice[t-1, i] = logsumexp([lp[i, k]+ld[k]+lr[k, c]+lv[c] for k in range(2) for c in range(2)], 
                                             b=[sp[i, k]*sd[k]*sr[k, c] for k in range(2) for c in range(2)])
            lv = bwdlattice[t-1]
        return bwdlattice

    def _do_forward_pass(self, framelogprob, lengths):
        n_samples, n_components = framelogprob.shape
        (lps, ilds, lp_invs), (sps, sds, sp_invs) = self.__get_lpdps(framelogprob)
        lds = ilds*lengths
        lds[0] -= ilds[0]
        fwdlattice = np.zeros((n_samples, n_components))
        lv = log_mask_zero(self.startprob_)+framelogprob[0]
        for t in range(n_samples):
            lp, ld, lr = (lps[t], lds[t], lp_invs[t])
            sp, sd, sr = (sps[t], sds[t], sp_invs[t])
            for j in range(2):
                fwdlattice[t, j] = logsumexp([lv[c] + lp[c, k]+ld[k]+lr[k, j] for k in range(2) for c in range(2)], 
                                             b=[sp[c, k]*sd[k]*sr[k, j] for k in range(2) for c in range(2)])
            lv = fwdlattice[t]
        with np.errstate(under="ignore"):
            return logsumexp(fwdlattice[-1]), fwdlattice

    def _accumulate_sufficient_statistics(self, stats, X, framelogprob,
                                          posteriors, fwdlattice, bwdlattice):
        """Updates sufficient statistics from a given sample.

        Parameters
        ----------
        stats : dict
            Sufficient statistics as returned by
            :meth:`~base._BaseHMM._initialize_sufficient_statistics`.

        X : array, shape (n_samples, n_features)
            Sample sequence.

        framelogprob : array, shape (n_samples, n_components)
            Log-probabilities of each sample under each of the model states.

        posteriors : array, shape (n_samples, n_components)
            Posterior probabilities of each sample being generated by each
            of the model states.

        fwdlattice, bwdlattice : array, shape (n_samples, n_components)
            Log-forward and log-backward probabilities.
        """
        stats['nobs'] += 1
        if 's' in self.params:
            stats['start'] += posteriors[0]
        if 't' in self.params:
            n_samples, n_components = framelogprob.shape
            # when the sample is of length 1, it contains no transitions
            # so there is no reason to update our trans. matrix estimate
            if n_samples <= 1:
                return

            log_xi_sum = np.full((n_components, n_components), -np.inf)
            _hmmc._compute_log_xi_sum(n_samples, n_components, fwdlattice,
                                      log_mask_zero(self.transmat_),
                                      bwdlattice, framelogprob,
                                      log_xi_sum)
            with np.errstate(under="ignore"):
                stats['trans'] += np.exp(log_xi_sum)

def compute_log_xi_sum(fwdlattice, log_transmat, bwdlattice, framelogprob, lengths):
    n_samples, n_components = framelogprob.shape
    logprob = logsumexp(fwdlattice[-1])
    log_xi_sum = np.zeros((n_samples, n_samples))
    for t in range(n_samples - 1):
        for i in range(n_components):
            for j in range(n_components):
                work_buffer[i, j] = (fwdlattice[t, i]
                                     + log_transmat[i, j]
                                     + framelogprob[t + 1, j]
                                     + bwdlattice[t + 1, j]
                                     - logprob)

        for i in range(n_components):
            for j in range(n_components):
                log_xi_sum[i, j] = _logaddexp(log_xi_sum[i, j],
                                              work_buffer[i, j])
